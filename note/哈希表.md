# å“ˆå¸Œè¡¨ã€ç§»åŠ¨è¯­ä¹‰

## åŸºæœ¬æ¦‚å¿µ

å“ˆå¸Œè¡¨ï¼ˆ`HashTable`ï¼‰æ˜¯ä¸€ä¸ªé‡è¦çš„åº•å±‚æ•°æ®ç»“æ„, æ— åºå…³è”å®¹å™¨åŒ…æ‹¬`unordered_set`, `unordered_map`å†…éƒ¨éƒ½æ˜¯åŸºäºå“ˆå¸Œè¡¨å®ç°ã€‚

- å“ˆå¸Œè¡¨æ˜¯ä¸€ç§é€šè¿‡å“ˆå¸Œå‡½æ•°å°†é”®æ˜ å°„åˆ°ç´¢å¼•çš„æ•°æ®ç»“æ„ï¼Œå­˜å‚¨åœ¨å†…å­˜ç©ºé—´ä¸­ã€‚
- å“ˆå¸Œå‡½æ•°è´Ÿè´£å°†ä»»æ„å¤§å°çš„è¾“å…¥æ˜ å°„åˆ°å›ºå®šå¤§å°çš„è¾“å‡ºï¼Œå³å“ˆå¸Œå€¼ã€‚è¿™ä¸ªå“ˆå¸Œå€¼ç”¨ä½œåœ¨æ•°ç»„ä¸­å­˜å‚¨é”®å€¼å¯¹çš„ç´¢å¼•ã€‚

### ç”¨é€”

é‚£ä¹ˆå“ˆå¸Œè¡¨èƒ½è§£å†³ä»€ä¹ˆé—®é¢˜å‘¢ï¼Œ**ä¸€èˆ¬å“ˆå¸Œè¡¨éƒ½æ˜¯ç”¨æ¥å¿«é€Ÿåˆ¤æ–­ä¸€ä¸ªå…ƒç´ æ˜¯å¦å‡ºç°é›†åˆé‡Œã€‚**

ä¾‹å¦‚è¦æŸ¥è¯¢ä¸€ä¸ªåå­—æ˜¯å¦åœ¨è¿™æ‰€å­¦æ ¡é‡Œã€‚

è¦æšä¸¾çš„è¯æ—¶é—´å¤æ‚åº¦æ˜¯O(n)ï¼Œä½†å¦‚æœä½¿ç”¨å“ˆå¸Œè¡¨çš„è¯ï¼Œ åªéœ€è¦O(1)å°±å¯ä»¥åšåˆ°ã€‚

æˆ‘ä»¬åªéœ€è¦åˆå§‹åŒ–æŠŠè¿™æ‰€å­¦æ ¡é‡Œå­¦ç”Ÿçš„åå­—éƒ½å­˜åœ¨å“ˆå¸Œè¡¨é‡Œï¼Œåœ¨æŸ¥è¯¢çš„æ—¶å€™é€šè¿‡ç´¢å¼•ç›´æ¥å°±å¯ä»¥çŸ¥é“è¿™ä½åŒå­¦åœ¨ä¸åœ¨è¿™æ‰€å­¦æ ¡é‡Œäº†ã€‚

å°†å­¦ç”Ÿå§“åæ˜ å°„åˆ°å“ˆå¸Œè¡¨ä¸Šå°±æ¶‰åŠåˆ°äº†**hash function ï¼Œä¹Ÿå°±æ˜¯å“ˆå¸Œå‡½æ•°**ã€‚

### å†²çªè§£å†³

ç”±äºå“ˆå¸Œå‡½æ•°çš„æ˜ å°„ä¸æ˜¯ä¸€å¯¹ä¸€çš„ï¼Œå¯èƒ½ä¼šå‡ºç°ä¸¤ä¸ªä¸åŒçš„é”®æ˜ å°„åˆ°ç›¸åŒçš„ç´¢å¼•ï¼Œå³å†²çªã€‚å¯ä»¥ä½¿ç”¨é“¾åœ°å€æ³•è§£å†³å†²çªï¼Œå³åœ¨å“ˆå¸Œè¡¨çš„æ¯ä¸ªæ§½ä¸­ç»´æŠ¤ä¸€ä¸ªé“¾è¡¨ï¼Œå°†å“ˆå¸Œå€¼ç›¸åŒçš„å…ƒç´ å­˜å‚¨åœ¨åŒä¸€ä¸ªæ§½ä¸­çš„é“¾è¡¨ä¸­ã€‚

### å“ˆå¸Œè¡¨çš„æ‰©å®¹ä¸`rehashing`

ä¸ºäº†é¿å…å“ˆå¸Œè¡¨ä¸­é“¾è¡¨è¿‡é•¿å¯¼è‡´æ€§èƒ½ä¸‹é™ï¼Œä¼šåœ¨éœ€è¦æ—¶è¿›è¡Œæ‰©å®¹ã€‚

æ‰©å®¹è¿‡ç¨‹æ¶‰åŠåˆ°é‡æ–°è®¡ç®—æ‰€æœ‰å…ƒç´ çš„å“ˆå¸Œå€¼ï¼Œå¹¶å°†å®ƒä»¬åˆ†å¸ƒåˆ°æ–°çš„æ›´å¤§çš„å“ˆå¸Œè¡¨ä¸­ã€‚è¿™ä¸€è¿‡ç¨‹ç§°ä¸º`rehashing`ã€‚

## æ€è·¯

```cpp
class HashNode{
public:
    Key key;
    Value value;
    ......;
}

using Bucket = std::list<HashNode>;
std::vector<Bucket> buckets;    // å®šä¹‰ç”±å¤šä¸ªæ§½è¿ç»­ç»„æˆçš„æ•°ç»„
```

åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¼šå®šä¹‰ä»¥ä¸‹å‡ ä¸ªå˜é‡åï¼Œå®ƒä»¬çš„æ„ä¹‰å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

- HashNodeè¡¨ç¤ºé“¾è¡¨çš„ä¸€ä¸ªèŠ‚ç‚¹
- Bucketè¡¨ç¤ºä¸€ä¸ªæ¡¶ï¼Œæ¡¶é‡Œé¢è£…çš„æ˜¯é“¾è¡¨ï¼Œå®é™…ä¸Šå› ä¸ºå†²çªï¼Œæ¡¶é‡Œé¢çš„é“¾è¡¨å¾€å¾€åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹
- bucketsè¡¨ç¤ºç³»ç»Ÿå¼€è¾Ÿä¸€å—å—Bucketå¤§å°çš„è¿ç»­å†…å­˜ç©ºé—´

![image-20240523174055456](https://yzfzzz.oss-cn-shenzhen.aliyuncs.com/image/image-20240523174055456.png)

ç„¶åæˆ‘ä»¬æ¨¡æ‹Ÿå“ˆå¸Œè¡¨çš„æ’å…¥æµç¨‹ï¼Œå¦‚ä¸‹å›¾çš„â‘ â‘¡â‘¢â‘£â‘¤ï¼š

![image-20240525202756758](https://yzfzzz.oss-cn-shenzhen.aliyuncs.com/image/image-20240525202756758.png)



- é¦–å…ˆæˆ‘ä»¬å®šä¹‰`std::vector<Bucket> buckets`ï¼Œå®ƒæ˜¯ä¸¤å—Bucketå¤§å°çš„è¿ç»­å†…å­˜ç©ºé—´ï¼Œä¹Ÿå°±æ˜¯ä¸¤ä¸ªæ¡¶ã€‚ä½†æ¡¶é‡Œé¢æ˜¯æ²¡æœ‰ä¸œè¥¿çš„
- å½“å‘å“ˆå¸Œè¡¨ä¸­æ’å…¥10æ—¶ï¼ˆ`insert(10)`ï¼‰ï¼Œé¦–å…ˆä¼šé€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºç´¢å¼•ï¼ˆ`hash(10)=0`ï¼‰ï¼Œé‚£ä¹ˆå°±åœ¨ç¬¬ä¸€ä¸ªæ¡¶ï¼ˆBucketï¼‰ä¸­æ”¾å…¥èŠ‚ç‚¹**â‘©**
- å½“å‘å“ˆå¸Œè¡¨ä¸­æ’å…¥0æ—¶ï¼ˆ`insert(0)`ï¼‰ï¼Œé¦–å…ˆä¼šé€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºç´¢å¼•ï¼ˆ`hash(0)=1`ï¼‰ï¼Œé‚£ä¹ˆå°±åœ¨ç¬¬äºŒä¸ªæ¡¶ï¼ˆBucketï¼‰ä¸­æ”¾å…¥èŠ‚ç‚¹**â“ª**
- å½“å‘å“ˆå¸Œè¡¨ä¸­æ’å…¥20æ—¶ï¼ˆ`insert(20)`ï¼‰ï¼Œé¦–å…ˆä¼šé€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºç´¢å¼•ï¼ˆ`hash(20)=1`ï¼‰ï¼Œå‡ºç°ä¸¤ä¸ªä¸åŒçš„é”®æ˜ å°„åˆ°ç›¸åŒçš„ç´¢å¼•ï¼Œå³å†²çªã€‚å¯ä»¥ä½¿ç”¨é“¾åœ°å€æ³•è§£å†³å†²çªï¼Œå³åœ¨å“ˆå¸Œè¡¨çš„æ¯ä¸ªæ§½ä¸­ç»´æŠ¤ä¸€ä¸ªé“¾è¡¨ã€‚
- ç”±äºæ¡¶çš„æ•°é‡ä¸å¤Ÿäº†ï¼Œéœ€è¦æ‰©å®¹å“ˆå¸Œè¡¨ï¼ˆ`rehash`ï¼‰ï¼Œæ‰©å®¹åçš„å®¹é‡ç¿»å€ã€‚é€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºç´¢å¼•ï¼ˆ`hash(20)=3`ï¼‰ï¼Œé‚£ä¹ˆå°±åœ¨ç¬¬å››ä¸ªæ¡¶ï¼ˆBucketï¼‰ä¸­æ”¾å…¥èŠ‚ç‚¹**â‘³**

## ä»£ç å®ç°

### HashTable.h

```cpp
#include <algorithm>
#include <cstddef>
#include <functional>
#include <iostream>
#include <list>
#include <utility>
#include <vector>
#include <sstream>
#include <string>

namespace mystl{
template <typename Key, typename Value, typename Hash = std::hash<Key>>
class HashTable{
  
  // é“¾è¡¨ä¸­è¦ç»´æŠ¤çš„jie'd
  class HashNode{
  public:
    Key key;
    Value value;
    
    // ä»Keyæ„é€ èŠ‚ç‚¹ï¼ŒValueä½¿ç”¨é»˜è®¤æ„é€ 
    explicit HashNode(const Key &key): key(key), value(){}
    
    // ä»Keyå’ŒValueæ„é€ èŠ‚ç‚¹
    HashNode(const Key &key, const Value &value):key(key), value(value){}
    
    // æ¯”è¾ƒè¿ç®—ç¬¦é‡è½½ï¼Œæ¯”è¾ƒkey
    bool operator==(const HashNode &other) const { return key == other.key;}
    bool operator!=(const HashNode &other) const { return key != other.key; }
    bool operator<(const HashNode &other) const { return key < other.key; }
    bool operator>(const HashNode &other) const { return key > other.key; }
    bool operator==(const Key &key_) const { return key == key_; }
    
    void print() const
    {
        std::cout<<"(" << key <<","<< value<<")" << " ";
    }
  };
  
private:
    // å®šä¹‰è¡¨ä¸­ä¸€ä¸ªæ¡¶ï¼ˆBucketï¼‰ï¼Œæ¡¶é‡Œé¢è£…çš„æ˜¯ä¸€ä¸ªä¸ªHashNodeèŠ‚ç‚¹ç»„æˆçš„é“¾è¡¨
    using Bucket = std::list<HashNode>;
    std::vector<Bucket> buckets;    // å®šä¹‰ç”±å¤šä¸ªæ§½è¿ç»­ç»„æˆçš„æ•°ç»„
    std::hash<Key> hashFunction;    // å®šä¹‰ä¸€ä¸ªå“ˆå¸Œå‡½æ•°
    size_t tableSize;               // å“ˆå¸Œè¡¨çš„æœ€å¤§å®¹é‡
    size_t numElements;             // å“ˆå¸Œè¡¨ä¸­å½“å‰å…ƒç´ çš„æ•°é‡
    float maxLoadFactor = 0.75;     // é»˜è®¤çš„æœ€å¤§è´Ÿè½½å› å­
    
    // å“ˆå¸Œå‡½æ•°è®¡ç®—keyçš„å€¼ï¼Œå–æ¨¡é˜²æ­¢æº¢å‡ºï¼Œä½œä¸ºå“ˆå¸Œè¡¨çš„ç´¢å¼•
    size_t hash(const Key &key) const { return hashFunction(key)%tableSize; }
    
    // å½“å…ƒç´ æ•°é‡å¤§äºæœ€å¤§å®¹é‡æ—¶ï¼Œå¢åŠ æ¡¶çš„æ•°é‡å¹¶é‡æ–°åˆ†é…æ‰€æœ‰é”®
    void rehash(size_t newSize)
    {
        std::vector<Bucket> newBuckets(newSize);// åˆ›å»ºä¸€ä¸ªæ–°çš„æ¡¶æ•°ç»„ï¼Œå¤§å°ä¸ºnewsize
        for(Bucket &bucket : buckets)           // éå†åŸæ¥çš„æ¡¶æ•°ç»„bucketsï¼Œè½®æµå–å‡ºå…¶ä¸­çš„ä¸€ä¸ªæ¡¶ï¼ˆbucketï¼‰
        {
            // é“¾è¡¨éå†
            for(HashNode &hashNode : bucket)    // éå†åŸæ¥çš„æ¡¶bucketï¼Œå®ƒæ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œè½®æµå–å‡ºå…¶ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆhashNodeï¼‰
            {
                // æ–°çš„ç´¢å¼•ä¸åŸæ¥çš„ç´¢å¼•ç›¸åŒ
                size_t newIndex = hashFunction(hashNode.key)%newSize;// è®¡ç®—æ–°çš„ç´¢å¼•
                newBuckets[newIndex].push_back(hashNode);
            }
        }
        // ç§»åŠ¨è¯­ä¹‰
        buckets = std::move(newBuckets);
        tableSize = newSize;
    }
    
public:
    // å“ˆå¸Œè¡¨æ„é€ å‡½æ•°åˆå§‹åŒ–, æ³¨æ„ï¼štypename Hash = std::hash<Key>
    /* 
        std::hash<Key>() åˆ›å»ºäº†ä¸€ä¸ªä¸´æ—¶çš„ std::hash<Key> å¯¹è±¡ã€‚
        å› ä¸º std::hash<Key> æœ‰ä¸€ä¸ªé»˜è®¤çš„æ„é€ å‡½æ•°ï¼ˆæ— å‚æ•°çš„æ„é€ å‡½æ•°ï¼‰ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥è¿™æ ·è°ƒç”¨å®ƒæ¥åˆ›å»ºä¸€ä¸ªä¸´æ—¶å¯¹è±¡ã€‚
        è¿™ä¸ªä¸´æ—¶å¯¹è±¡è¢«ç”¨æ¥åˆå§‹åŒ–ä¹‹åï¼Œå°±é”€æ¯
    */ 
    HashTable(size_t size = 0, const std::hash<Key> &hashFunc = Hash()):buckets(size),hashFunction(hashFunc),tableSize(size),numElements(0){}
    // å°†é”®å€¼å¯¹æ’å…¥å“ˆå¸Œè¡¨ä¸­
    void insert(const Key &key, const Value &value)
    {
        if((numElements + 1) > maxLoadFactor * tableSize)   // ä¹˜ä»¥ä¸€ä¸ªè´Ÿè½½å› å­ï¼Œä¿è¯å“ˆå¸Œè¡¨é¢„ç•™çš„ç©ºé—´è¶³å¤Ÿå¤šï¼Œè®¡ç®—å‡ºçš„ç´¢å¼•ä¸å®¹æ˜“å‘ç”Ÿå†²çªï¼Œå‡å°‘æ‹·è´æ¬¡æ•°
        {
            if(tableSize == 0)
                tableSize = 1;
            rehash(tableSize * 2);
        }
        size_t index = hash(key);   // è®¡ç®—ç´¢å¼•
        Bucket &bucket = buckets[index];    // æ‰¾å‡ºè¯¥ç´¢å¼•å¯¹åº”çš„æ¡¶
        if(std::find(bucket.begin(),bucket.end(),key) == bucket.end())  //  å¦‚æœæ¡¶ä¸­æ²¡æœ‰é“¾è¡¨ï¼Œåˆ™åœ¨è¯¥æ¡¶ä¸­æ’å…¥è¯¥é“¾è¡¨ï¼›å¦‚æœæœ‰ï¼Œåˆ™ç›´æ¥è·³è¿‡
        {
            bucket.push_back(HashNode(key, value));
            numElements++;
        }
    }
    
    void insertKey(const Key &key) { insert(key, Value{}); }    // å€¼ä¸ºç©ºçš„æƒ…å†µ
    
    void erase(const Key &key)
    {
        size_t index = hash(key);   // è®¡ç®—ç´¢å¼•
        auto &bucket = buckets[index];  // æ‰¾å‡ºè¯¥ç´¢å¼•å¯¹åº”çš„æ¡¶
        auto it = std::find(bucket.begin(), bucket.end(), key);
        if(it != bucket.end())
        {
            // æ‰¾åˆ°è¯¥é“¾è¡¨ï¼Œåˆ é™¤å®ƒ
            bucket.erase(it);
            numElements--;
        }
    }
    
    Value* find(const Key &key)
    {
        size_t index = hash(key);
        auto &bucket = buckets[index];
        auto ans = std::find(bucket.begin(), bucket.end(), key);
        if(ans != bucket.end())
        {
            return &ans->value; // è¿”å›ç»“ç‚¹valueæ‰€åœ¨çš„åœ°å€
        }
        return nullptr;
    }
    
    size_t size() const { return numElements; }
    void print() const 
    {
        for(size_t i = 0; i < buckets.size(); i++)
        {
            for(const HashNode &element : buckets[i])
            {
                element.print();    // è°ƒç”¨HashNodeç±»çš„æˆå‘˜å‡½æ•°print
            }
        }
        std::cout << std::endl;
    }
    
    void clear()
    {
        this->buckets.clear();
        this->numElements = 0;
        this->tableSize = 0;
    }
};
}
```

### test.cpp

```cpp
#include "vector.h"
#include "list.h"
#include "deque.h"
#include "HashTable.h"

void HashTableTest()
{
    mystl::HashTable<int, int> hashTable;
    for(int i = 0;i<5;i++)
    {
        hashTable.insert(i, i*2);
        hashTable.print();
    }
    hashTable.print();
    int* t = hashTable.find(3);
    std::cout << *t << std::endl;
    hashTable.erase(3);
    hashTable.print();
    hashTable.clear();
    hashTable.print();
}

int main()
{
    HashTableTest();
    system("pause");
    return 0;
}
```

## ä»£ç è¯¦è§£

ä»£ç çš„æ³¨é‡Šå·²ç»å¾ˆè¯¦ç»†å•¦ï¼Œæ‰€ä»¥å°±ä¸ä¸€ä¸ªä¸ªè®²äº†ï¼ˆå…¶å®æˆ‘å°±æ˜¯æ‡’~ğŸ˜œï¼‰

ä¸»è¦è®²è§£ä¸€ä¸‹ç§»åŠ¨è¯­ä¹‰è¿™ä¸ªçŸ¥è¯†ç‚¹

## ç§»åŠ¨è¯­ä¹‰

==å‚è€ƒè¿™ç¯‡åšå®¢ï¼Œå†™å¾—éå¸¸å¥½ğŸ™‚ï¼š[[c++11\]æˆ‘ç†è§£çš„å³å€¼å¼•ç”¨ã€ç§»åŠ¨è¯­ä¹‰å’Œå®Œç¾è½¬å‘ - ç®€ä¹¦ (jianshu.com)](https://www.jianshu.com/p/d19fc8447eaa)==

**std::move()å¯ä»¥è®©ä¸€ä¸ªå·¦å€¼è¿›è¡Œå³å€¼å¼•ç”¨ï¼Œè¿™æ ·åœ¨ç»™å…¶å®ƒå˜é‡èµ‹å€¼çš„æ—¶å€™ï¼Œå°±ä¸ç”¨é¢å¤–æ‹·è´ä¸€æ¬¡ä¸´æ—¶å˜é‡**ã€‚

é‚£ä»€ä¹ˆå«å·¦ã€å³å€¼ï¼Ÿä»€ä¹ˆå«å·¦å€¼å¼•ç”¨ã€å³å€¼å¼•ç”¨å‘¢ï¼Ÿ

### å·¦å€¼å³å€¼

`C++`ä¸­æ‰€æœ‰çš„å€¼éƒ½å¿…ç„¶å±äºå·¦å€¼ã€å³å€¼äºŒè€…ä¹‹ä¸€ã€‚å·¦å€¼æ˜¯æŒ‡è¡¨è¾¾å¼ç»“æŸåä¾ç„¶å­˜åœ¨çš„*æŒä¹…åŒ–å¯¹è±¡*ï¼Œå³å€¼æ˜¯æŒ‡è¡¨è¾¾å¼ç»“æŸæ—¶å°±ä¸å†å­˜åœ¨çš„*ä¸´æ—¶å¯¹è±¡*ã€‚æ‰€æœ‰çš„æœ‰åå­—çš„å˜é‡æˆ–è€…å¯¹è±¡éƒ½æ˜¯å·¦å€¼ï¼Œè€Œå³å€¼åˆ™æ²¡æœ‰åå­—ã€‚

- å·¦å€¼ï¼š`int a = 10`
- å³å€¼ï¼šå¦‚ `1+2` äº§ç”Ÿçš„ä¸´æ—¶å˜é‡ï¼Œ`2ï¼Œ'c'ï¼Œtrueï¼Œ"hello"`ç­‰

å¾ˆéš¾å¾—åˆ°å·¦å€¼å’Œå³å€¼çš„çœŸæ­£å®šä¹‰ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªå¯ä»¥åŒºåˆ†å·¦å€¼å’Œå³å€¼çš„ä¾¿æ·æ–¹æ³•ï¼š**çœ‹èƒ½ä¸èƒ½å¯¹è¡¨è¾¾å¼å–åœ°å€ï¼Œå¦‚æœèƒ½ï¼Œåˆ™ä¸ºå·¦å€¼ï¼Œå¦åˆ™ä¸ºå³å€¼**ã€‚

### å·¦å€¼å¼•ç”¨ï¼Œå³å€¼å¼•ç”¨

å·¦å€¼å¼•ç”¨å°±æ˜¯æˆ‘ä»¬ç»å¸¸è¯´çš„å¼•ç”¨ï¼Œä¹Ÿå°±æ˜¯ç»™å˜é‡å–åˆ«åï¼Œè¦æ³¨æ„ä¸èƒ½ç»™å³å€¼å–å·¦å€¼å¼•ç”¨ï¼Œå› ä¸ºå½“æˆ‘ä»¬ä¿®æ”¹bçš„å€¼æ—¶ï¼Œå°±æ˜¯ä¿®æ”¹1çš„å€¼ï¼Œä½†ç”±äº1æ²¡æœ‰å†…å­˜ç©ºé—´ï¼Œä¿®æ”¹ä¸äº†ï¼Œæ‰€ä»¥ä¸ç¬¦åˆå·¦å€¼å¼•ç”¨çš„è¦æ±‚

```cpp
int a = 10; 
int& refA = a; // refAæ˜¯açš„åˆ«åï¼Œ ä¿®æ”¹refAå°±æ˜¯ä¿®æ”¹a, aæ˜¯å·¦å€¼ï¼Œå·¦ç§»æ˜¯å·¦å€¼å¼•ç”¨
int& b = 1; // !ç¼–è¯‘é”™è¯¯! 1æ˜¯å³å€¼ï¼Œä¸èƒ½å¤Ÿä½¿ç”¨å·¦å€¼å¼•ç”¨
```

`c++11`ä¸­çš„å³å€¼å¼•ç”¨ä½¿ç”¨çš„ç¬¦å·æ˜¯`&&`ï¼Œå®ƒå…è®¸æˆ‘ä»¬å¯¹å³å€¼è¿›è¡Œå¼•ç”¨ï¼Œå¦‚ï¼š

```cpp
int&& a = 1; //å®è´¨ä¸Šå°±æ˜¯å°†ä¸å…·å(åŒ¿å)å˜é‡å–äº†ä¸ªåˆ«å
int b = 1;
int && c = b; //ç¼–è¯‘é”™è¯¯ï¼ ä¸èƒ½å°†ä¸€ä¸ªå·¦å€¼å¤åˆ¶ç»™ä¸€ä¸ªå³å€¼å¼•ç”¨
class A {
  public:
    int a;
};
A getTemp()
{
    return A();
}
A && a = getTemp();   //getTemp()çš„è¿”å›å€¼æ˜¯å³å€¼ï¼ˆä¸´æ—¶å˜é‡ï¼‰

```

åŒæ ·æˆ‘ä»¬ä¹Ÿè¦æ³¨æ„ä¸èƒ½ç»™å·¦å€¼å–å³å€¼å¼•ç”¨

åœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œ`getTemp()`è¿”å›çš„å³å€¼æœ¬æ¥åœ¨è¡¨è¾¾å¼è¯­å¥ç»“æŸåï¼Œå…¶ç”Ÿå‘½ä¹Ÿå°±è¯¥ç»ˆç»“äº†ï¼ˆå› ä¸ºæ˜¯ä¸´æ—¶å˜é‡ï¼‰ï¼Œè€Œé€šè¿‡å³å€¼å¼•ç”¨ï¼Œè¯¥å³å€¼åˆé‡è·æ–°ç”Ÿï¼Œå…¶ç”Ÿå‘½æœŸå°†ä¸å³å€¼å¼•ç”¨ç±»å‹å˜é‡`a`çš„ç”Ÿå‘½æœŸä¸€æ ·ï¼Œåªè¦`a`è¿˜æ´»ç€ï¼Œè¯¥å³å€¼ä¸´æ—¶å˜é‡å°†ä¼šä¸€ç›´å­˜æ´»ä¸‹å»ã€‚å®é™…ä¸Šå°±æ˜¯ç»™é‚£ä¸ªä¸´æ—¶å˜é‡å–äº†ä¸ªåå­—ã€‚

**æ³¨æ„**ï¼šè¿™é‡Œ`a`çš„ç±»å‹æ˜¯å³å€¼å¼•ç”¨ç±»å‹(`int &&`)ï¼Œä½†æ˜¯å¦‚æœä»å·¦å€¼å’Œå³å€¼çš„è§’åº¦åŒºåˆ†å®ƒï¼Œå®ƒå®é™…ä¸Šæ˜¯ä¸ªå·¦å€¼ã€‚å› ä¸ºå¯ä»¥å¯¹å®ƒå–åœ°å€ï¼Œè€Œä¸”å®ƒè¿˜æœ‰åå­—ï¼Œæ˜¯ä¸€ä¸ªå·²ç»å‘½åçš„å³å€¼ã€‚å› æ­¤ï¼Œç¼–è¯‘å™¨ä¼šè®¤ä¸ºaæ˜¯ä¸ªå·¦å€¼ã€‚

### ä¸‡èƒ½å¼•ç”¨

é‚£æœ‰æ²¡æœ‰ä¸€ç§å¼•ç”¨ï¼Œæ—¢å¯ä»¥å·¦å€¼å¼•ç”¨ï¼Œä¹Ÿå¯ä»¥å³å€¼å¼•ç”¨å‘¢ï¼Ÿ

æœ‰ï¼Œå®ƒå°±æ˜¯å¸¸é‡å¼•ç”¨ã€‚**å¸¸é‡å·¦å€¼å¼•ç”¨**æ˜¯ä¸ªå¥‡è‘©ï¼Œå®ƒå¯ä»¥ç®—æ˜¯ä¸€ä¸ªâ€œä¸‡èƒ½â€çš„å¼•ç”¨ç±»å‹ï¼Œå®ƒå¯ä»¥ç»‘å®šéå¸¸é‡å·¦å€¼ã€å¸¸é‡å·¦å€¼ã€å³å€¼ï¼Œè€Œä¸”åœ¨ç»‘å®šå³å€¼çš„æ—¶å€™ï¼Œå¸¸é‡å·¦å€¼å¼•ç”¨è¿˜å¯ä»¥åƒå³å€¼å¼•ç”¨ä¸€æ ·å°†å³å€¼çš„ç”Ÿå‘½æœŸå»¶é•¿ï¼Œç¼ºç‚¹æ˜¯ï¼Œåªèƒ½è¯»ä¸èƒ½æ”¹ã€‚

```cpp
const int & a = 1; //å¸¸é‡å·¦å€¼å¼•ç”¨ç»‘å®š å³å€¼ï¼Œ ä¸ä¼šæŠ¥é”™

class A {
  public:
    int a;
};
A getTemp()
{
    return A();
}
const A & a = getTemp();   //ä¸ä¼šæŠ¥é”™ è€Œ A& a ä¼šæŠ¥é”™
```

> æ€»ç»“ä¸€ä¸‹ï¼š
>
> 1. å·¦å€¼å¼•ç”¨ï¼Œ ä½¿ç”¨ `T&`, åªèƒ½ç»‘å®š**å·¦å€¼**
> 2. å³å€¼å¼•ç”¨ï¼Œ ä½¿ç”¨ `T&&`ï¼Œ åªèƒ½ç»‘å®š**å³å€¼**
> 3. å¸¸é‡å·¦å€¼ï¼Œ ä½¿ç”¨ `const T&`, æ—¢å¯ä»¥ç»‘å®š**å·¦å€¼**åˆå¯ä»¥ç»‘å®š**å³å€¼**
> 4. å·²å‘½åçš„**å³å€¼å¼•ç”¨**ï¼Œç¼–è¯‘å™¨ä¼šè®¤ä¸ºæ˜¯ä¸ª**å·¦å€¼**



### ç§»åŠ¨è¯­ä¹‰ã€æ‹·è´

```cpp
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

class MyString
{
public:
    static size_t CCtor; //ç»Ÿè®¡è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°çš„æ¬¡æ•°
//    static size_t CCtor; //ç»Ÿè®¡è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°çš„æ¬¡æ•°
public:
    // æ„é€ å‡½æ•°
   MyString(const char* cstr=0){
       if (cstr) {
          m_data = new char[strlen(cstr)+1];
          strcpy(m_data, cstr);
       }
       else {
          m_data = new char[1];
          *m_data = '\0';
       }
   }

   // æ‹·è´æ„é€ å‡½æ•°
   MyString(const MyString& str) {
       CCtor ++;
       m_data = new char[ strlen(str.m_data) + 1 ];
       strcpy(m_data, str.m_data);
   }
   // æ‹·è´èµ‹å€¼å‡½æ•° =å·é‡è½½
   MyString& operator=(const MyString& str){
       if (this == &str) // é¿å…è‡ªæˆ‘èµ‹å€¼!!
          return *this;

       delete[] m_data;
       m_data = new char[ strlen(str.m_data) + 1 ];
       strcpy(m_data, str.m_data);
       return *this;
   }

   ~MyString() {
       delete[] m_data;
   }

   char* get_c_str() const { return m_data; }
private:
   char* m_data;
};
size_t MyString::CCtor = 0;

int main()
{
    vector<MyString> vecStr;
    vecStr.reserve(1000); //å…ˆåˆ†é…å¥½1000ä¸ªç©ºé—´ï¼Œä¸è¿™ä¹ˆåšï¼Œè°ƒç”¨çš„æ¬¡æ•°å¯èƒ½è¿œå¤§äº1000
    for(int i=0;i<1000;i++){
        vecStr.push_back(MyString("hello"));
    }
    cout << MyString::CCtor << endl;
}
```

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œ`vecStr.push_back(MyString("hello"))`å·¥ä½œæµç¨‹å¦‚å›¾ï¼šå®ƒä¼šä¾æ¬¡è°ƒç”¨`MyString(const char* cstr=0)`åˆ›å»ºä¸€ä¸ªå³å€¼ã€åœ¨æ’å…¥çš„æ—¶å€™é€šè¿‡MyString(const MyString& str)`æ‹·è´ä¸€ä»½Mystringå˜é‡

![image-20240525195943736](https://yzfzzz.oss-cn-shenzhen.aliyuncs.com/image/image-20240525195943736.png)

å¦‚æœ`MyString("hello")`æ„é€ å‡ºæ¥çš„å­—ç¬¦ä¸²ï¼ˆæ¯”å¦‚`MyString("hello abcdefghigklmnopqrstuvwsyzasdâ€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦")`ï¼‰æœ¬æ¥å°±å¾ˆé•¿ï¼Œæ„é€ ä¸€éå°±å¾ˆè€—æ—¶äº†ï¼Œæœ€åå´è¿˜è¦æ‹·è´ä¸€éï¼Œè€Œ`MyString("hello")`åªæ˜¯ä¸´æ—¶å¯¹è±¡ï¼Œæ‹·è´å®Œå°±æ²¡ä»€ä¹ˆç”¨äº†ï¼Œè¿™å°±é€ æˆäº†æ²¡æœ‰æ„ä¹‰çš„èµ„æºç”³è¯·å’Œé‡Šæ”¾æ“ä½œã€‚

é‚£èƒ½ä¸èƒ½å»æ‰è¿™ä¸ªcopyï¼ˆé»„è‰²ç®­å¤´ï¼‰æ‹·è´è¿‡ç¨‹ï¼Œç›´æ¥å°†è¿™ä¸ªå³å€¼æ’å…¥å‘¢ï¼Ÿè€Œ`C++11`æ–°å¢åŠ çš„**ç§»åŠ¨è¯­ä¹‰**å°±èƒ½å¤Ÿåšåˆ°è¿™ä¸€ç‚¹ã€‚

```cpp
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

class MyString
{
public:
    static size_t CCtor; //ç»Ÿè®¡è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°çš„æ¬¡æ•°
    static size_t MCtor; //ç»Ÿè®¡è°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•°çš„æ¬¡æ•°
    static size_t CAsgn; //ç»Ÿè®¡è°ƒç”¨æ‹·è´èµ‹å€¼å‡½æ•°çš„æ¬¡æ•°
    static size_t MAsgn; //ç»Ÿè®¡è°ƒç”¨ç§»åŠ¨èµ‹å€¼å‡½æ•°çš„æ¬¡æ•°

public:
    // æ„é€ å‡½æ•°
   MyString(const char* cstr=0){
       if (cstr) {
          m_data = new char[strlen(cstr)+1];
          strcpy(m_data, cstr);
       }
       else {
          m_data = new char[1];
          *m_data = '\0';
       }
   }

   // æ‹·è´æ„é€ å‡½æ•°
   MyString(const MyString& str) {
       CCtor ++;
       m_data = new char[ strlen(str.m_data) + 1 ];
       strcpy(m_data, str.m_data);
   }
   // ç§»åŠ¨æ„é€ å‡½æ•°
   MyString(MyString&& str) noexcept
       :m_data(str.m_data) {
       MCtor ++;
       str.m_data = nullptr; //ä¸å†æŒ‡å‘ä¹‹å‰çš„èµ„æºäº†
   }

   // æ‹·è´èµ‹å€¼å‡½æ•° =å·é‡è½½
   MyString& operator=(const MyString& str){
       CAsgn ++;
       if (this == &str) // é¿å…è‡ªæˆ‘èµ‹å€¼!!
          return *this;

       delete[] m_data;
       m_data = new char[ strlen(str.m_data) + 1 ];
       strcpy(m_data, str.m_data);
       return *this;
   }

   // ç§»åŠ¨èµ‹å€¼å‡½æ•° =å·é‡è½½
   MyString& operator=(MyString&& str) noexcept{
       MAsgn ++;
       if (this == &str) // é¿å…è‡ªæˆ‘èµ‹å€¼!!
          return *this;

       delete[] m_data;
       m_data = str.m_data;
       str.m_data = nullptr; //ä¸å†æŒ‡å‘ä¹‹å‰çš„èµ„æºäº†
       return *this;
   }

   ~MyString() {
       delete[] m_data;
   }

   char* get_c_str() const { return m_data; }
private:
   char* m_data;
};
size_t MyString::CCtor = 0;
size_t MyString::MCtor = 0;
size_t MyString::CAsgn = 0;
size_t MyString::MAsgn = 0;
int main()
{
    vector<MyString> vecStr;
    vecStr.reserve(1000); //å…ˆåˆ†é…å¥½1000ä¸ªç©ºé—´
    for(int i=0;i<1000;i++){
        vecStr.push_back(MyString("hello"));
    }
    cout << "CCtor = " << MyString::CCtor << endl;
    cout << "MCtor = " << MyString::MCtor << endl;
    cout << "CAsgn = " << MyString::CAsgn << endl;
    cout << "MAsgn = " << MyString::MAsgn << endl;
}

/* ç»“æœ
CCtor = 0
MCtor = 1000
CAsgn = 0
MAsgn = 0
*/
```

åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œæˆ‘ä»¬æ–°å¢äº†ä¸€ä¸ªç§»åŠ¨æ‹·è´æ„é€ ï¼š

```cpp
// ç§»åŠ¨æ„é€ å‡½æ•°
MyString(MyString&& str) noexcept:m_data(str.m_data) {
    MCtor ++;
    str.m_data = nullptr; //ä¸å†æŒ‡å‘ä¹‹å‰çš„èµ„æºäº†
}
```

ç§»åŠ¨æ„é€ å‡½æ•°ä¸æ‹·è´æ„é€ å‡½æ•°çš„åŒºåˆ«æ˜¯ï¼Œæ‹·è´æ„é€ çš„å‚æ•°æ˜¯`const MyString& str`ï¼Œæ˜¯*å¸¸é‡å·¦å€¼å¼•ç”¨*ï¼Œè€Œç§»åŠ¨æ„é€ çš„å‚æ•°`MyString&& str`ï¼Œæ˜¯*å³å€¼å¼•ç”¨*ï¼Œè€Œ`MyString("hello")`æ˜¯ä¸ªä¸´æ—¶å¯¹è±¡ï¼Œæ˜¯ä¸ªå³å€¼ï¼Œä¼˜å…ˆè¿›å…¥**ç§»åŠ¨æ„é€ å‡½æ•°**è€Œä¸æ˜¯æ‹·è´æ„é€ å‡½æ•°ã€‚è€Œç§»åŠ¨æ„é€ å‡½æ•°ä¸æ‹·è´æ„é€ ä¸åŒï¼Œå®ƒå¹¶ä¸æ˜¯é‡æ–°åˆ†é…ä¸€å—æ–°çš„ç©ºé—´ï¼Œå°†è¦æ‹·è´çš„å¯¹è±¡å¤åˆ¶è¿‡æ¥ï¼Œè€Œæ˜¯"å·"äº†è¿‡æ¥ï¼Œå°†è‡ªå·±çš„æŒ‡é’ˆæŒ‡å‘åˆ«äººçš„èµ„æºï¼Œç„¶åå°†åˆ«äººçš„æŒ‡é’ˆä¿®æ”¹ä¸º`nullptr`ï¼Œè¿™ä¸€æ­¥å¾ˆé‡è¦ï¼Œå¦‚æœä¸å°†åˆ«äººçš„æŒ‡é’ˆä¿®æ”¹ä¸ºç©ºï¼Œé‚£ä¹ˆä¸´æ—¶å¯¹è±¡ææ„çš„æ—¶å€™å°±ä¼šé‡Šæ”¾æ‰è¿™ä¸ªèµ„æºï¼Œ"å·"ä¹Ÿç™½å·äº†ã€‚ä¸‹é¢è¿™å¼ å›¾å¯ä»¥è§£é‡Šcopyå’Œmoveçš„åŒºåˆ«ã€‚

![img](https://yzfzzz.oss-cn-shenzhen.aliyuncs.com/image/4427263-81a47fdc9b8d9e98.png)

é€šè¿‡è¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å°±å¯ä»¥è®©ä¸€ä¸ªå³å€¼ï¼Œä¸ç”¨è¿›è¡Œæ‹·è´ï¼Œç›´æ¥ç§»åŠ¨åˆ°è¯¥å»çš„åœ°æ–¹

å¯¹äºä¸€ä¸ªå·¦å€¼ï¼Œè‚¯å®šæ˜¯è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°äº†ã€‚æ¯”å¦‚ä¸Šé¢æˆ‘ä»¬å°†mainå‡½æ•°ä¿®æ”¹ä¸€ä¸‹ï¼š

```cpp
int main()
{
    vector<MyString> vecStr;
    vecStr.reserve(1000); //å…ˆåˆ†é…å¥½1000ä¸ªç©ºé—´
    for(int i=0;i<1000;i++){
        MyString s = MyString("hello");
        vecStr.push_back(s);
    }
    cout << "CCtor = " << MyString::CCtor << endl;
    cout << "MCtor = " << MyString::MCtor << endl;
    cout << "CAsgn = " << MyString::CAsgn << endl;
    cout << "MAsgn = " << MyString::MAsgn << endl;
}
```

**å¯ä»¥çœ‹å‡ºè¿™ä¸ªå·¦å€¼ï¼Œè¿›å…¥åˆ°äº†æ‹·è´æ„é€ é‡Œé¢äº†ï¼Œè€Œä¸æ˜¯ç§»åŠ¨æ„é€ ä¸­ï¼**

ä½†æ˜¯æœ‰äº›å·¦å€¼æ˜¯å±€éƒ¨å˜é‡ï¼Œç”Ÿå‘½å‘¨æœŸä¹Ÿå¾ˆçŸ­ï¼Œèƒ½ä¸èƒ½ä¹Ÿç§»åŠ¨è€Œä¸æ˜¯æ‹·è´å‘¢ï¼Ÿ`C++11`ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæä¾›äº†`std::move()`æ–¹æ³•æ¥å°†å·¦å€¼è½¬æ¢ä¸ºå³å€¼ï¼Œä»è€Œæ–¹ä¾¿åº”ç”¨ç§»åŠ¨è¯­ä¹‰ã€‚

æˆ‘è§‰å¾—å®ƒå…¶å®å°±æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œè™½ç„¶æˆ‘æ˜¯ä¸€ä¸ªå·¦å€¼ï¼Œä½†æ˜¯ä¸è¦å¯¹æˆ‘ç”¨æ‹·è´æ„é€ å‡½æ•°ï¼Œè€Œæ˜¯ç”¨ç§»åŠ¨æ„é€ å‡½æ•°å§ã€‚

ç°åœ¨æˆ‘ä»¬å†å°†mainå‡½æ•°ä¿®æ”¹ä¸€ä¸‹ï¼š

```cpp
int main()
{
    vector<MyString> vecStr;
    vecStr.reserve(1000); //å…ˆåˆ†é…å¥½1000ä¸ªç©ºé—´
    for(int i=0;i<1000;i++){
        MyString s = MyString("hello");
        vecStr.push_back(std::move(s));
    }
    cout << "CCtor = " << MyString::CCtor << endl;
    cout << "MCtor = " << MyString::MCtor << endl;
    cout << "CAsgn = " << MyString::CAsgn << endl;
    cout << "MAsgn = " << MyString::MAsgn << endl;
}
```

**å¯ä»¥çœ‹å‡ºè¿™ä¸ªå·¦å€¼ï¼Œè¿›å…¥åˆ°äº†ç§»åŠ¨æ„é€ é‡Œé¢äº†ï¼**

**æ‰€ä»¥ï¼šstd::move()å¯ä»¥è®©ä¸€ä¸ªå·¦å€¼è¿›è¡Œå³å€¼å¼•ç”¨ï¼Œè¿™æ ·åœ¨ç»™å…¶å®ƒå˜é‡èµ‹å€¼çš„æ—¶å€™ï¼Œå°±ä¸ç”¨é¢å¤–æ‹·è´ä¸€æ¬¡ä¸´æ—¶å˜é‡ã€‚**

## C11ä¸­å…ƒç´ éå†`Bucket &bucket:buckets`

ç­‰åŒäº

```cpp
for(int i =0;i<buckets.size();i++)
{
	bucket = buckets[i];
    â€¦â€¦â€¦â€¦
}
```









